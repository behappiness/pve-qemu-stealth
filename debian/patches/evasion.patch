Description: Name changes for anti-detection
 Mostly changed device names, id's, serial numbers
Author: behappiness
Origin: <upstream|backport|vendor|other>, <URL, required except if Author is present>
Bug: <URL to the upstream bug report if any, implies patch has been forwarded, optional>
Bug-<Vendor>: <URL to the vendor bug report if any, optional>
Forwarded: <URL|no|not-needed, useless if you have a Bug field, optional>
Applied-Upstream: <version|URL|commit, identifies patches merged upstream, optional>
Reviewed-by: <name and email of a reviewer, optional>
Last-Update: 2024-12-31 <YYYY-MM-DD, last update of the meta-information, optional>
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
Index: qemu/block/vhdx.c
===================================================================
--- qemu.orig/block/vhdx.c
+++ qemu/block/vhdx.c
@@ -2009,7 +2009,7 @@ vhdx_co_create(BlockdevCreateOptions *op
 
     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("MSI v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
Index: qemu/block/vvfat.c
===================================================================
--- qemu.orig/block/vvfat.c
+++ qemu/block/vvfat.c
@@ -1077,7 +1077,7 @@ static QemuOptsList runtime_opts = {
         {
             .name = "label",
             .type = QEMU_OPT_STRING,
-            .help = "Use a volume label other than QEMU VVFAT",
+            .help = "Use a volume label other than MSI VFAT",
         },
         {
             .name = "rw",
@@ -1176,7 +1176,7 @@ static int vvfat_open(BlockDriverState *
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "MSI VVFAT", 10);
     }
 
     if (floppy) {
Index: qemu/chardev/msmouse.c
===================================================================
--- qemu.orig/chardev/msmouse.c
+++ qemu/chardev/msmouse.c
@@ -172,7 +172,7 @@ static int msmouse_chr_write(struct Char
 }
 
 static QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
Index: qemu/contrib/vhost-user-gpu/vhost-user-gpu.c
===================================================================
--- qemu.orig/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ qemu/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1251,7 +1251,7 @@ main(int argc, char *argv[])
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);
 
-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
Index: qemu/chardev/wctablet.c
===================================================================
--- qemu.orig/chardev/wctablet.c
+++ qemu/chardev/wctablet.c
@@ -179,7 +179,7 @@ static void wctablet_input_sync(DeviceSt
 }
 
 static QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
Index: qemu/hw/arm/nseries.c
===================================================================
--- qemu.orig/hw/arm/nseries.c
+++ qemu/hw/arm/nseries.c
@@ -849,7 +849,7 @@ static void n800_setup_nolo_tags(void *s
 
     memset(p, 0, 0x3000);
 
-    strcpy((void *) (p + 0), "QEMU N800");
+    strcpy((void *) (p + 0), "Nokia N800");
 
     strcpy((void *) (p + 8), "F5");
 
@@ -1152,7 +1152,7 @@ static int n8x0_atag_setup(void *p, int
 
     stw_p(w++, OMAP_TAG_LCD);			/* u16 tag */
     stw_p(w++, 36);				/* u16 len */
-    strcpy((void *) w, "QEMU LCD panel");	/* char panel_name[16] */
+    strcpy((void *) w, "Samsung LCD panel");	/* char panel_name[16] */
     w += 8;
     strcpy((void *) w, "blizzard");		/* char ctrl_name[16] */
     w += 8;
@@ -1272,11 +1272,11 @@ static int n8x0_atag_setup(void *p, int
     stw_p(w++, 24);				/* u16 len */
     strcpy((void *) w, "hw-build");		/* char component[12] */
     w += 6;
-    strcpy((void *) w, "QEMU ");
+    strcpy((void *) w, "Nokia");
     pstrcat((void *) w, 12, qemu_hw_version()); /* char version[12] */
     w += 6;
 
-    tag = (model == 810) ? "1.1.10-qemu" : "1.1.6-qemu";
+    tag = (model == 810) ? "1.1.10" : "1.1.6";
     stw_p(w++, OMAP_TAG_VERSION_STR);		/* u16 tag */
     stw_p(w++, 24);				/* u16 len */
     strcpy((void *) w, "nolo");			/* char component[12] */
Index: qemu/hw/arm/sbsa-ref.c
===================================================================
--- qemu.orig/hw/arm/sbsa-ref.c
+++ qemu/hw/arm/sbsa-ref.c
@@ -897,7 +897,7 @@ static void sbsa_ref_class_init(ObjectCl
     MachineClass *mc = MACHINE_CLASS(oc);
 
     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n1");
     mc->max_cpus = 512;
     mc->pci_allow_0_address = true;
Index: qemu/hw/arm/virt-acpi-build.c
===================================================================
--- qemu.orig/hw/arm/virt-acpi-build.c
+++ qemu/hw/arm/virt-acpi-build.c
@@ -97,7 +97,7 @@ static void acpi_dsdt_add_uart(Aml *scop
 static void acpi_dsdt_add_fw_cfg(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("AMD69420")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
Index: qemu/hw/arm/virt.c
===================================================================
--- qemu.orig/hw/arm/virt.c
+++ qemu/hw/arm/virt.c
@@ -87,7 +87,7 @@
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         virt_machine_##major##_##minor##_options(mc); \
-        mc->desc = "QEMU " # major "." # minor " ARM Virtual Machine"; \
+        mc->desc = "AMD  " # major "." # minor " ARM Machine"; \
         if (latest) { \
             mc->alias = "virt"; \
         } \
@@ -1619,13 +1619,13 @@ static void virt_build_smbios(VirtMachin
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "AMD Machine";
     }
 
-    smbios_set_defaults("QEMU", product,
+    smbios_set_defaults("Unknown", product,
                         vmc->smbios_old_sys_ver ? "1.0" : mc->name, false,
                         true, SMBIOS_ENTRY_POINT_TYPE_64);
 
Index: qemu/hw/char/escc.c
===================================================================
--- qemu.orig/hw/char/escc.c
+++ qemu/hw/char/escc.c
@@ -1037,7 +1037,7 @@ static void escc_realize(DeviceState *de
 
     if (s->chn[0].type == escc_mouse) {
         qemu_add_mouse_event_handler(sunmouse_event, &s->chn[0], 0,
-                                     "QEMU Sun Mouse");
+                                     "Sun Mouse");
     }
     if (s->chn[1].type == escc_kbd) {
         s->chn[1].hs = qemu_input_handler_register((DeviceState *)(&s->chn[1]),
Index: qemu/hw/display/edid-generate.c
===================================================================
--- qemu.orig/hw/display/edid-generate.c
+++ qemu/hw/display/edid-generate.c
@@ -394,10 +394,10 @@ void qemu_edid_generate(uint8_t *edid, s
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "MSI Monitor";
     }
     if (!info->prefx) {
         info->prefx = 1280;
@@ -449,7 +449,7 @@ void qemu_edid_generate(uint8_t *edid, s
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
Index: qemu/hw/i386/acpi-build.c
===================================================================
--- qemu.orig/hw/i386/acpi-build.c
+++ qemu/hw/i386/acpi-build.c
@@ -2638,6 +2638,14 @@ void acpi_build(AcpiBuildTables *tables,
         g_array_append_vals(tables_blob, u, len);
     }
 
+    /* Disable BGRT (UEFI Logo)*/
+    acpi_add_table(table_offsets, tables_blob);
+    AcpiTable table = { .sig = "BGRT", .rev = 1,
+                        .oem_id = x86ms->oem_id, .oem_table_id = x86ms->oem_table_id };
+    acpi_table_begin(&table, tables_blob);
+    build_append_int_noprefix(tables_blob,0x00000000,4);
+    acpi_table_end(tables->linker, &table);
+
     /* RSDT is pointed to by RSDP */
     rsdt = tables_blob->len;
     build_rsdt(tables_blob, tables->linker, table_offsets,
Index: qemu/hw/i386/fw_cfg.c
===================================================================
--- qemu.orig/hw/i386/fw_cfg.c
+++ qemu/hw/i386/fw_cfg.c
@@ -205,7 +205,7 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FW
     Aml *dev = aml_device("FWCF");
     Aml *crs = aml_resource_template();
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("MSI0002")));
 
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
Index: qemu/hw/i386/pc.c
===================================================================
--- qemu.orig/hw/i386/pc.c
+++ qemu/hw/i386/pc.c
@@ -110,9 +110,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },
 
 GlobalProperty pc_compat_8_0[] = {
     { "virtio-mem", "unplugged-inaccessible", "auto" },
Index: qemu/hw/i386/pc_piix.c
===================================================================
--- qemu.orig/hw/i386/pc_piix.c
+++ qemu/hw/i386/pc_piix.c
@@ -237,7 +237,7 @@ static void pc_init1(MachineState *machi
     if (pcmc->smbios_defaults) {
         MachineClass *mc = MACHINE_GET_CLASS(machine);
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc,
+        smbios_set_defaults("Unknown", mc->desc,
                             mc->name, pcmc->smbios_legacy_mode,
                             pcmc->smbios_uuid_encoded,
                             pcms->smbios_entry_point_type);
Index: qemu/hw/i386/pc_q35.c
===================================================================
--- qemu.orig/hw/i386/pc_q35.c
+++ qemu/hw/i386/pc_q35.c
@@ -199,7 +199,7 @@ static void pc_q35_init(MachineState *ma
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc,
+        smbios_set_defaults("Unknown", mc->desc,
                             mc->name, pcmc->smbios_legacy_mode,
                             pcmc->smbios_uuid_encoded,
                             pcms->smbios_entry_point_type);
Index: qemu/hw/ide/atapi.c
===================================================================
--- qemu.orig/hw/ide/atapi.c
+++ qemu/hw/ide/atapi.c
@@ -797,8 +797,8 @@ static void cmd_inquiry(IDEState *s, uin
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "MSI");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
Index: qemu/hw/ide/core.c
===================================================================
--- qemu.orig/hw/ide/core.c
+++ qemu/hw/ide/core.c
@@ -2618,20 +2618,20 @@ int ide_init_drive(IDEState *s, BlockBac
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);
     } else {
         snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+                 "WJI436MZJMJF65L%05d", s->drive_serial);
     }
     if (model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "MicroSD J45S9");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
Index: qemu/hw/input/adb-kbd.c
===================================================================
--- qemu.orig/hw/input/adb-kbd.c
+++ qemu/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@ static void adb_kbd_reset(DeviceState *d
 }
 
 static QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
Index: qemu/hw/input/adb-mouse.c
===================================================================
--- qemu.orig/hw/input/adb-mouse.c
+++ qemu/hw/input/adb-mouse.c
@@ -236,7 +236,7 @@ static void adb_mouse_realizefn(DeviceSt
 
     amc->parent_realize(dev, errp);
 
-    qemu_add_mouse_event_handler(adb_mouse_event, s, 0, "QEMU ADB Mouse");
+    qemu_add_mouse_event_handler(adb_mouse_event, s, 0, "ADB Mouse");
 }
 
 static void adb_mouse_initfn(Object *obj)
Index: qemu/hw/input/ads7846.c
===================================================================
--- qemu.orig/hw/input/ads7846.c
+++ qemu/hw/input/ads7846.c
@@ -154,7 +154,7 @@ static void ads7846_realize(SSIPeriphera
 
     /* We want absolute coordinates */
     qemu_add_mouse_event_handler(ads7846_ts_event, s, 1,
-                    "QEMU ADS7846-driven Touchscreen");
+                    "ADS7846-driven Touchscreen");
 
     ads7846_int_update(s);
 
Index: qemu/hw/input/hid.c
===================================================================
--- qemu.orig/hw/input/hid.c
+++ qemu/hw/input/hid.c
@@ -511,20 +511,20 @@ void hid_free(HIDState *hs)
 }
 
 static QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };
 
 static QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };
 
 static QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
Index: qemu/hw/input/ps2.c
===================================================================
--- qemu.orig/hw/input/ps2.c
+++ qemu/hw/input/ps2.c
@@ -1232,7 +1232,7 @@ static const VMStateDescription vmstate_
 };
 
 static QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@ static void ps2_kbd_realize(DeviceState
 }
 
 static QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
Index: qemu/hw/input/tsc2005.c
===================================================================
--- qemu.orig/hw/input/tsc2005.c
+++ qemu/hw/input/tsc2005.c
@@ -510,7 +510,7 @@ void *tsc2005_init(qemu_irq pintdav)
     tsc2005_reset(s);
 
     qemu_add_mouse_event_handler(tsc2005_touchscreen_event, s, 1,
-                    "QEMU TSC2005-driven Touchscreen");
+                    "TSC2005-driven Touchscreen");
 
     qemu_register_reset((void *) tsc2005_reset, s);
     vmstate_register(NULL, 0, &vmstate_tsc2005, s);
Index: qemu/hw/input/tsc210x.c
===================================================================
--- qemu.orig/hw/input/tsc210x.c
+++ qemu/hw/input/tsc210x.c
@@ -1105,7 +1105,7 @@ uWireSlave *tsc2102_init(qemu_irq pint)
     tsc210x_reset(s);
 
     qemu_add_mouse_event_handler(tsc210x_touchscreen_event, s, 1,
-                    "QEMU TSC2102-driven Touchscreen");
+                    "TSC2102-driven Touchscreen");
 
     AUD_register_card(s->name, &s->card);
 
@@ -1153,7 +1153,7 @@ uWireSlave *tsc2301_init(qemu_irq penirq
     tsc210x_reset(s);
 
     qemu_add_mouse_event_handler(tsc210x_touchscreen_event, s, 1,
-                    "QEMU TSC2301-driven Touchscreen");
+                    "TSC2301-driven Touchscreen");
 
     AUD_register_card(s->name, &s->card);
 
Index: qemu/hw/input/virtio-input-hid.c
===================================================================
--- qemu.orig/hw/input/virtio-input-hid.c
+++ qemu/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@
 
 #include "standard-headers/linux/input.h"
 
-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"
 
 /* ----------------------------------------------------------------- */
 
Index: qemu/hw/loongarch/virt.c
===================================================================
--- qemu.orig/hw/loongarch/virt.c
+++ qemu/hw/loongarch/virt.c
@@ -311,13 +311,13 @@ static void virt_build_smbios(LoongArchM
     MachineClass *mc = MACHINE_GET_CLASS(lams);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";
 
     if (!lams->fw_cfg) {
         return;
     }
 
-    smbios_set_defaults("QEMU", product, mc->name, false,
+    smbios_set_defaults("Unknown", product, mc->name, false,
                         true, SMBIOS_ENTRY_POINT_TYPE_64);
 
     smbios_get_tables(ms, NULL, 0, &smbios_tables, &smbios_tables_len,
Index: qemu/hw/m68k/virt.c
===================================================================
--- qemu.orig/hw/m68k/virt.c
+++ qemu/hw/m68k/virt.c
@@ -302,7 +302,7 @@ static void virt_init(MachineState *mach
 static void virt_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "AMD M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -331,7 +331,7 @@ type_init(virt_machine_register_types)
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         virt_machine_##major##_##minor##_options(mc); \
-        mc->desc = "QEMU " # major "." # minor " M68K Virtual Machine"; \
+        mc->desc = "AMD " # major "." # minor " M68K Machine"; \
         if (latest) { \
             mc->alias = "virt"; \
         } \
Index: qemu/hw/pci-host/gpex.c
===================================================================
--- qemu.orig/hw/pci-host/gpex.c
+++ qemu/hw/pci-host/gpex.c
@@ -207,7 +207,7 @@ static void gpex_root_class_init(ObjectC
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "MSI generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
Index: qemu/hw/ppc/e500plat.c
===================================================================
--- qemu.orig/hw/ppc/e500plat.c
+++ qemu/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@
 
 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";
 
     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
Index: qemu/hw/riscv/virt-acpi-build.c
===================================================================
--- qemu.orig/hw/riscv/virt-acpi-build.c
+++ qemu/hw/riscv/virt-acpi-build.c
@@ -100,7 +100,7 @@ static void acpi_dsdt_add_cpus(Aml *scop
 static void acpi_dsdt_add_fw_cfg(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("AMD90210")));
 
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
Index: qemu/hw/scsi/scsi-bus.c
===================================================================
--- qemu.orig/hw/scsi/scsi-bus.c
+++ qemu/hw/scsi/scsi-bus.c
@@ -581,8 +581,8 @@ static bool scsi_target_emulate_inquiry(
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
Index: qemu/hw/scsi/scsi-disk.c
===================================================================
--- qemu.orig/hw/scsi/scsi-disk.c
+++ qemu/hw/scsi/scsi-disk.c
@@ -2509,7 +2509,7 @@ static void scsi_realize(SCSIDevice *dev
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (!s->device_id) {
         if (s->serial) {
@@ -2564,7 +2564,7 @@ static void scsi_hd_realize(SCSIDevice *
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 out:
@@ -2598,7 +2598,7 @@ static void scsi_cd_realize(SCSIDevice *
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
     aio_context_release(ctx);
Index: qemu/hw/scsi/spapr_vscsi.c
===================================================================
--- qemu.orig/hw/scsi/spapr_vscsi.c
+++ qemu/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@ static void vscsi_inquiry_no_target(VSCS
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "EMPTY           ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);
 
     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@ static int vscsi_send_adapter_info(VSCSI
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
Index: qemu/hw/smbios/smbios.c
===================================================================
--- qemu.orig/hw/smbios/smbios.c
+++ qemu/hw/smbios/smbios.c
@@ -613,11 +613,11 @@ static void smbios_build_type_0_table(vo
 
     t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */
 
-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
+    t->bios_characteristics = cpu_to_le64(0); /* Not supported */
     t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_characteristics_extension_bytes[1] = 0; /* TCD/SVVP | VM */
     if (type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
+        t->bios_characteristics_extension_bytes[1] |= 0; /* |= UEFI */
     }
 
     if (type0.have_major_minor) {
Index: qemu/hw/usb/canokey.c
===================================================================
--- qemu.orig/hw/usb/canokey.c
+++ qemu/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = "HTH2S87KYL"
 };
 
 static const USBDescDevice desc_device_canokey = {
Index: qemu/hw/usb/dev-audio.c
===================================================================
--- qemu.orig/hw/usb/dev-audio.c
+++ qemu/hw/usb/dev-audio.c
@@ -73,8 +73,8 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
+    [STRING_MANUFACTURER]       = "MSI",
+    [STRING_PRODUCT]            = "USB Audio",
     [STRING_SERIALNUMBER]       = "1",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
@@ -1005,7 +1005,7 @@ static void usb_audio_class_init(ObjectC
     dc->vmsd          = &vmstate_usb_audio;
     device_class_set_props(dc, usb_audio_properties);
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
-    k->product_desc   = "QEMU USB Audio Interface";
+    k->product_desc   = "USB Audio Interface";
     k->realize        = usb_audio_realize;
     k->handle_reset   = usb_audio_handle_reset;
     k->handle_control = usb_audio_handle_control;
Index: qemu/hw/usb/dev-hid.c
===================================================================
--- qemu.orig/hw/usb/dev-hid.c
+++ qemu/hw/usb/dev-hid.c
@@ -63,10 +63,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
+    [STR_MANUFACTURER]     = "MSI",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
     [STR_SERIAL_COMPAT]    = "42",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
@@ -806,7 +806,7 @@ static void usb_tablet_class_initfn(Obje
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -829,7 +829,7 @@ static void usb_mouse_class_initfn(Objec
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -853,7 +853,7 @@ static void usb_keyboard_class_initfn(Ob
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
Index: qemu/hw/usb/dev-hub.c
===================================================================
--- qemu.orig/hw/usb/dev-hub.c
+++ qemu/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "MSI",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "CQ4FPJO3Q7",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectC
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
Index: qemu/hw/usb/dev-mtp.c
===================================================================
--- qemu.orig/hw/usb/dev-mtp.c
+++ qemu/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(MTPState, USB
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "MSI"
+#define MTP_PRODUCT       "MSI filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -264,7 +264,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "Q2GXVI497Q",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2091,7 +2091,7 @@ static void usb_mtp_class_initfn(ObjectC
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
Index: qemu/hw/usb/dev-network.c
===================================================================
--- qemu.orig/hw/usb/dev-network.c
+++ qemu/hw/usb/dev-network.c
@@ -99,15 +99,15 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
+    [STRING_MANUFACTURER]       = "MSI",
+    [STRING_PRODUCT]            = "RNDIS USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
     [STRING_SERIALNUMBER]       = "1",
 };
 
@@ -725,7 +725,7 @@ static int ndis_query(USBNetState *s, ui
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1426,7 +1426,7 @@ static void usb_net_class_initfn(ObjectC
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
Index: qemu/hw/usb/dev-serial.c
===================================================================
--- qemu.orig/hw/usb/dev-serial.c
+++ qemu/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "MSI",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "3IM7RRFDLM",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -666,7 +666,7 @@ static void usb_serial_class_initfn(Obje
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -687,7 +687,7 @@ static void usb_braille_class_initfn(Obj
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
Index: qemu/hw/usb/dev-smartcard-reader.c
===================================================================
--- qemu.orig/hw/usb/dev-smartcard-reader.c
+++ qemu/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState,
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "MSI"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "MSI",
+    [STR_PRODUCT]       = "MSI USB CCID",
+    [STR_SERIALNUMBER]  = "TP1VIQN6JG",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1443,7 +1443,7 @@ static void ccid_class_initfn(ObjectClas
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
Index: qemu/hw/usb/dev-storage.c
===================================================================
--- qemu.orig/hw/usb/dev-storage.c
+++ qemu/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "MSI",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "2P8G7QZWB0",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -591,7 +591,7 @@ static void usb_msd_class_initfn_common(
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
Index: qemu/hw/usb/dev-uas.c
===================================================================
--- qemu.orig/hw/usb/dev-uas.c
+++ qemu/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "MSI",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "7BQQK28NNK",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
Index: qemu/hw/usb/dev-wacom.c
===================================================================
--- qemu.orig/hw/usb/dev-wacom.c
+++ qemu/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "MSI",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "CN42QZ0CVU",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectC
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectC
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
Index: qemu/hw/usb/u2f-emulated.c
===================================================================
--- qemu.orig/hw/usb/u2f-emulated.c
+++ qemu/hw/usb/u2f-emulated.c
@@ -386,7 +386,7 @@ static void u2f_emulated_class_init(Obje
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
Index: qemu/hw/usb/u2f-passthru.c
===================================================================
--- qemu.orig/hw/usb/u2f-passthru.c
+++ qemu/hw/usb/u2f-passthru.c
@@ -531,7 +531,7 @@ static void u2f_passthru_class_init(Obje
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
Index: qemu/hw/usb/u2f.c
===================================================================
--- qemu.orig/hw/usb/u2f.c
+++ qemu/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "MSI",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "4ASV0H36UK",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectCla
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectCla
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
Index: qemu/include/hw/acpi/aml-build.h
===================================================================
--- qemu.orig/include/hw/acpi/aml-build.h
+++ qemu/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "ALASKA"
+#define ACPI_BUILD_APPNAME8 "A M I "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
Index: qemu/include/standard-headers/linux/qemu_fw_cfg.h
===================================================================
--- qemu.orig/include/standard-headers/linux/qemu_fw_cfg.h
+++ qemu/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"AMD69420"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
Index: qemu/migration/rdma.c
===================================================================
--- qemu.orig/migration/rdma.c
+++ qemu/migration/rdma.c
@@ -250,7 +250,7 @@ static const char *control_desc(unsigned
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
Index: qemu/pc-bios/s390-ccw/virtio-scsi.h
===================================================================
--- qemu.orig/pc-bios/s390-ccw/virtio-scsi.h
+++ qemu/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "MSI CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
Index: qemu/qapi/ui.json
===================================================================
--- qemu.orig/qapi/ui.json
+++ qemu/qapi/ui.json
@@ -839,13 +839,13 @@
 # -> { "execute": "query-mice" }
 # <- { "return": [
 #          {
-#             "name":"QEMU Microsoft Mouse",
+#             "name":"Microsoft Mouse",
 #             "index":0,
 #             "current":false,
 #             "absolute":false
 #          },
 #          {
-#             "name":"QEMU PS/2 Mouse",
+#             "name":"Microsoft PS/2 Mouse",
 #             "index":1,
 #             "current":true,
 #             "absolute":true
Index: qemu/target/i386/kvm/kvm.c
===================================================================
--- qemu.orig/target/i386/kvm/kvm.c
+++ qemu/target/i386/kvm/kvm.c
@@ -1550,7 +1550,7 @@ static int hyperv_fill_cpuids(CPUState *
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memcpy(signature, "AuthenticAMD", 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1558,7 +1558,7 @@ static int hyperv_fill_cpuids(CPUState *
 
         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memcpy(signature, "AuthenticAMD", 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -1829,7 +1829,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;
 
-        memcpy(signature, "XenVMMXenVMM", 12);
+        memcpy(signature, "AuthenticAMD", 12);
 
         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -1901,7 +1901,7 @@ int kvm_arch_init_vcpu(CPUState *cs)
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memcpy(signature, "AuthenticAMD", 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
Index: qemu/target/s390x/cpu_models.c
===================================================================
--- qemu.orig/target/s390x/cpu_models.c
+++ qemu/target/s390x/cpu_models.c
@@ -880,7 +880,7 @@ static void s390_qemu_cpu_model_class_in
     S390CPUClass *xcc = S390_CPU_CLASS(oc);
 
     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }
 
Index: qemu/target/s390x/tcg/misc_helper.c
===================================================================
--- qemu.orig/target/s390x/tcg/misc_helper.c
+++ qemu/target/s390x/tcg/misc_helper.c
@@ -328,18 +328,18 @@ uint32_t HELPER(stsi)(CPUS390XState *env
             /* Basic Machine Configuration */
             char type[5] = {};
 
-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "MSI             ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "MSI             ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "MSI             ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "MSI", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "MSIMSIMSIMSIMSI ", 16);
+            ebcdic_put(sysib.sysib_121.plant, "MSI ", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -354,8 +354,8 @@ uint32_t HELPER(stsi)(CPUS390XState *env
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "MSIMSIMSIMSIMSI ", 16);
+            ebcdic_put(sysib.sysib_221.plant, "MSI ", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -363,7 +363,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "MSI     ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -379,7 +379,7 @@ uint32_t HELPER(stsi)(CPUS390XState *env
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "MSI             ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */
 
             /* If our VM has a name, use the real name */
Index: qemu/target/i386/cpu.c
===================================================================
--- qemu.orig/target/i386/cpu.c
+++ qemu/target/i386/cpu.c
@@ -2202,7 +2202,7 @@ static const X86CPUDefinition builtin_x8
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -2317,7 +2317,7 @@ static const X86CPUDefinition builtin_x8
              VMX_CPU_BASED_UNCOND_IO_EXITING | VMX_CPU_BASED_USE_IO_BITMAPS |
              VMX_CPU_BASED_MONITOR_EXITING | VMX_CPU_BASED_PAUSE_EXITING,
         .xlevel = 0x80000008,
-        .model_id = "Common KVM processor"
+        .model_id = "Common AMD processor"
     },
     {
         .name = "qemu32",
@@ -2331,7 +2331,7 @@ static const X86CPUDefinition builtin_x8
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -2361,7 +2361,7 @@ static const X86CPUDefinition builtin_x8
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit AMD processor"
     },
     {
         .name = "coreduo",
@@ -2457,7 +2457,7 @@ static const X86CPUDefinition builtin_x8
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -4980,7 +4980,7 @@ static void max_x86_cpu_initfn(Object *o
     object_property_set_str(OBJECT(cpu), "vendor", CPUID_VENDOR_AMD,
                             &error_abort);
     object_property_set_str(OBJECT(cpu), "model-id",
-                            "QEMU TCG CPU version " QEMU_HW_VERSION,
+                            "TCG CPU version " QEMU_HW_VERSION,
                             &error_abort);
 }
 
@@ -7183,7 +7183,7 @@ static void x86_cpu_hyperv_realize(X86CP
 
     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "AuthenticAMD",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
Index: qemu/hw/audio/hda-codec.c
===================================================================
--- qemu.orig/hw/audio/hda-codec.c
+++ qemu/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x1022
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
Index: qemu/hw/misc/pvpanic-isa.c
===================================================================
--- qemu.orig/hw/misc/pvpanic-isa.c
+++ qemu/hw/misc/pvpanic-isa.c
@@ -70,7 +70,7 @@ static void build_pvpanic_isa_aml(AcpiDe
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("ASUS0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
Index: qemu/roms/seabios/src/fw/ssdt-misc.dsl
===================================================================
--- qemu.orig/roms/seabios/src/fw/ssdt-misc.dsl
+++ qemu/roms/seabios/src/fw/ssdt-misc.dsl
@@ -61,7 +61,7 @@ DefinitionBlock ("ssdt-misc.aml", "SSDT"
 
     Scope(\_SB.PCI0.ISA) {
         Device(PEVT) {
-            Name(_HID, "QEMU0001")
+            Name(_HID, "ASUS0001")
             /* PEST will be patched to be Zero if no such device */
             ACPI_EXTRACT_NAME_WORD_CONST ssdt_isa_pest
             Name(PEST, 0xFFFF)
Index: qemu/roms/seabios-hppa/src/fw/ssdt-misc.dsl
===================================================================
--- qemu.orig/roms/seabios-hppa/src/fw/ssdt-misc.dsl
+++ qemu/roms/seabios-hppa/src/fw/ssdt-misc.dsl
@@ -61,7 +61,7 @@ DefinitionBlock ("ssdt-misc.aml", "SSDT"
 
     Scope(\_SB.PCI0.ISA) {
         Device(PEVT) {
-            Name(_HID, "QEMU0001")
+            Name(_HID, "ASUS0001")
             /* PEST will be patched to be Zero if no such device */
             ACPI_EXTRACT_NAME_WORD_CONST ssdt_isa_pest
             Name(PEST, 0xFFFF)
Index: qemu/hw/nvme/ctrl.c
===================================================================
--- qemu.orig/hw/nvme/ctrl.c
+++ qemu/hw/nvme/ctrl.c
@@ -8171,7 +8171,7 @@ static void nvme_init_ctrl(NvmeCtrl *n,
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
Index: qemu/hw/scsi/mptconfig.c
===================================================================
--- qemu.orig/hw/scsi/mptconfig.c
+++ qemu/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
Index: qemu/hw/acpi/aml-build.c
===================================================================
--- qemu.orig/hw/acpi/aml-build.c
+++ qemu/hw/acpi/aml-build.c
@@ -1724,11 +1724,11 @@ void acpi_table_begin(AcpiTable *desc, G
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "PTL ", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
